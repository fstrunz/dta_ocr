import argparse
import sqlite3
import time
from enum import Enum
from dataclasses import dataclass
from typing import List
from pathlib import Path
from calamari_ocr.ocr.predict.predictor import MultiPredictor
from dta_ocr import create_progress_schema


def create_predictor(model_path: Path) -> MultiPredictor:
    checkpoints: List[str] = [
        str(model_path / model_file.stem)
        for model_file in model_path.iterdir()
        if model_file.is_file() and model_file.suffix == ".json"
    ]

    return MultiPredictor.from_paths(checkpoints)


def schedule_segmented_documents(conn: sqlite3.Connection):
    seg_cursor = conn.execute(
        """SELECT dta_dirname, page_number FROM segmentations
        WHERE status = 'finished'
        ORDER BY dta_dirname, page_number"""
    )

    conn.executemany(
        """INSERT OR IGNORE INTO predictions (
            dta_dirname, page_number, prediction_path, status
        ) VALUES ( ?, ?, NULL, 'pending' )""",
        seg_cursor
    )

    conn.commit()
    seg_cursor.close()


class Typeface(Enum):
    ANTIQUA = "Antiqua"
    FRAKTUR = "Fraktur"


@dataclass
class Prediction:
    dta_dirname: str
    page_number: int
    tei_path: Path


def fetch_scheduled_predictions(conn: sqlite3.Connection) -> List[Prediction]:
    pred_cursor = conn.execute(
        """SELECT dta_dirname, page_number, tei_path
        FROM predictions pred
        NATURAL JOIN documents doc
        WHERE pred.status != 'finished'"""
    )

    return [
        Prediction(dta_dirname, page_number, tei_path)
        for dta_dirname, page_number, tei_path in pred_cursor
    ]


def predict(
    facsimile_path: Path, antiqua_pred: MultiPredictor,
    fraktur_pred: MultiPredictor, scheduled: List[Prediction]
):
    pass


def main():
    arg_parser = argparse.ArgumentParser(
        "predict",
        description=(
            "Given a set of facsimiles with segmentations, in the same " +
            "format as the output of segment.py, Calamari is used to " +
            "predict the contents of the generated segmentations."
        )
    )
    arg_parser.add_argument(
        "--facsimile-dir", dest="facsimile_dir", default="facsimiles",
        help=(
            "The facsimile directory as generated by download.py " +
            "and segment.py."
        )
    )
    arg_parser.add_argument(
        "--antiqua-dir", dest="antiqua_dir",
        default="./models/prediction/antiqua",
        help="The path of the Antiqua model directory to use for prediction."
    )
    arg_parser.add_argument(
        "--fraktur-dir", dest="fraktur_dir",
        default="./models/prediction/fraktur",
        help="The path of the Fraktur model directory to use for prediction."
    )
    arg_parser.add_argument(
        "--progress-file", dest="progress_file", default="progress.db",
        help=(
            "The location of a SQLite database which stores the progress " +
            "the dta_ocr scripts have made.\n" +
            "The database will be created if it does not exist!"
        )
    )

    args = arg_parser.parse_args()
    facsimile_path = Path(args.facsimile_dir)
    if not facsimile_path.is_dir():
        print(
            f"The given facsimile path ({facsimile_path}) is not a directory!"
        )
        exit(1)

    antiqua_path = Path(args.antiqua_dir)
    if not antiqua_path.is_dir():
        print(
            f"The given Antiqua path ({antiqua_path}) is not a " +
            "directory!"
        )
        exit(1)

    fraktur_path = Path(args.fraktur_dir)
    if not fraktur_path.is_dir():
        print(
            f"The given Fraktur path ({fraktur_path}) is not a " +
            "directory!"
        )
        exit(1)

    print("Loading predictors...")
    antiqua_pred = create_predictor(antiqua_path)
    fraktur_pred = create_predictor(fraktur_path)

    with sqlite3.connect(args.progress_file) as conn:
        create_progress_schema(conn)
        schedule_segmented_documents(conn)

        sched = list(fetch_scheduled_predictions(conn))
        while True:
            if sched:
                predict(facsimile_path, antiqua_pred, fraktur_pred, sched)
            else:
                print("No work to be done. Waiting for more segmentations...")
                time.sleep(10.0)

            schedule_segmented_documents(conn)
            sched = list(fetch_scheduled_predictions(conn))


if __name__ == "__main__":
    main()
